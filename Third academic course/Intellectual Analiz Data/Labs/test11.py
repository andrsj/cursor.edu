import numpy as np

def nonlin(x, deriv=False):
    if (deriv == True): 
        return x * (1 - x) 
    return 1 / (1 + np.exp(-x)) # набір вхідних даних 

X = np.array([[0, 0, 1], [0, 1, 1], [1, 0, 1], [1, 1, 1]]) # вхідні дані 
y = np.array([[0, 0, 1, 1]]).T # ініціалізація вхідних даних. 3 входи і 1 вихід # однаковий розподіл чисел 
# np.random.seed(1) # ініціалізація ваг випадковим чином з середнім 0 
syn0 = 2 * np.random.random((3, 1)) - 1 

for iter in range(10000): # цикл тренування мережі # прямий розподіл 
    l0 = X # В х міститься 4 тренувальних приклади, групове тренування 
    l1 = nonlin(np.dot(l0, syn0)) # крок передбачення. напрям в сторону покращення. 2 кроки,матричне перемноження l0 і syn0, передача виходу серез сигмоїду # похибка. промах мережі 
    
    l1_error = y - l1 
    l1_delta = l1_error * nonlin(l1, True) # похідна(nonlin)  
    syn0 += np.dot(l0.T, l1_delta) # оновлення ваг

print ("Вихідні дані після тренування:") 
print (l1)